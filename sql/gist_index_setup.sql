-- GiST Index Setup for RostGIS
-- This file creates the necessary operator class and index method for spatial indexing

-- First, create the GiST support functions if they don't exist
-- These are automatically generated by pgrx, but we need to reference them

-- Create the operator class for GiST indexing
-- This tells PostgreSQL how to use our geometry type with GiST indexes
CREATE OPERATOR CLASS gist_geometry_ops
    DEFAULT FOR TYPE geometry USING gist AS
        -- Storage type for index entries (bounding box)
        STORAGE bbox,
        
        -- Operators that can use the index (with strategy numbers)
        OPERATOR 1  << (geometry, geometry),          -- left
        OPERATOR 2  &< (geometry, geometry),          -- overleft  
        OPERATOR 3  && (geometry, geometry),          -- overlaps
        OPERATOR 4  &> (geometry, geometry),          -- overright
        OPERATOR 5  >> (geometry, geometry),          -- right
        OPERATOR 6  ~= (geometry, geometry),          -- same
        OPERATOR 7  ~ (geometry, geometry),           -- contains
        OPERATOR 8  @ (geometry, geometry),           -- contained
        OPERATOR 9  <<| (geometry, geometry),         -- below
        OPERATOR 10 &<| (geometry, geometry),         -- overbelow
        OPERATOR 11 |&> (geometry, geometry),         -- overabove
        OPERATOR 12 |>> (geometry, geometry),         -- above
        
        -- Support functions for the index implementation
        FUNCTION 1 geometry_gist_consistent(internal, bbox, smallint, oid, internal),
        FUNCTION 2 geometry_gist_union(internal, internal),
        FUNCTION 3 geometry_gist_compress(geometry),
        FUNCTION 4 geometry_gist_decompress(internal),
        FUNCTION 5 geometry_gist_penalty(internal, internal, internal),
        FUNCTION 6 geometry_gist_picksplit(internal, internal),
        FUNCTION 7 geometry_gist_same(bbox, bbox, internal);

-- Create some example spatial indexes to demonstrate usage
-- Note: These would typically be created by users on their tables

-- Example of creating a GiST index on a geometry column:
-- CREATE INDEX spatial_data_geom_idx ON spatial_data USING GIST (geom);

-- Create a helper function to create spatial indexes
CREATE OR REPLACE FUNCTION create_spatial_index(
    table_name TEXT,
    column_name TEXT DEFAULT 'geom',
    index_name TEXT DEFAULT NULL
) RETURNS TEXT AS $$
DECLARE
    idx_name TEXT;
BEGIN
    -- Generate index name if not provided
    IF index_name IS NULL THEN
        idx_name := table_name || '_' || column_name || '_idx';
    ELSE
        idx_name := index_name;
    END IF;
    
    -- Create the GiST index
    EXECUTE format('CREATE INDEX %I ON %I USING GIST (%I)', 
                   idx_name, table_name, column_name);
    
    -- Update table statistics
    EXECUTE format('ANALYZE %I', table_name);
    
    RETURN format('Created spatial index %s on %s.%s', idx_name, table_name, column_name);
END;
$$ LANGUAGE plpgsql;

-- Create a helper function to check if spatial indexes exist
CREATE OR REPLACE FUNCTION has_spatial_index(
    table_name TEXT,
    column_name TEXT DEFAULT 'geom'
) RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 
        FROM pg_class c
        JOIN pg_index i ON c.oid = i.indexrelid
        JOIN pg_class t ON i.indrelid = t.oid
        JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(i.indkey)
        JOIN pg_am am ON c.relam = am.oid
        WHERE t.relname = table_name
        AND a.attname = column_name
        AND am.amname = 'gist'
    );
END;
$$ LANGUAGE plpgsql;

-- Create a function to get index usage statistics
CREATE OR REPLACE FUNCTION spatial_index_stats(
    table_name TEXT DEFAULT NULL
) RETURNS TABLE (
    schema_name TEXT,
    table_name TEXT,
    index_name TEXT,
    column_name TEXT,
    index_size TEXT,
    idx_scan BIGINT,
    idx_tup_read BIGINT,
    idx_tup_fetch BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        n.nspname::TEXT,
        t.relname::TEXT,
        i.relname::TEXT,
        a.attname::TEXT,
        pg_size_pretty(pg_relation_size(i.oid))::TEXT,
        COALESCE(s.idx_scan, 0),
        COALESCE(s.idx_tup_read, 0), 
        COALESCE(s.idx_tup_fetch, 0)
    FROM pg_class i
    JOIN pg_index idx ON i.oid = idx.indexrelid
    JOIN pg_class t ON idx.indrelid = t.oid
    JOIN pg_namespace n ON t.relnamespace = n.oid
    JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(idx.indkey)
    JOIN pg_am am ON i.relam = am.oid
    LEFT JOIN pg_stat_user_indexes s ON s.indexrelid = i.oid
    WHERE am.amname = 'gist'
    AND (table_name IS NULL OR t.relname = spatial_index_stats.table_name)
    AND a.atttypid = (SELECT oid FROM pg_type WHERE typname = 'geometry')
    ORDER BY n.nspname, t.relname, i.relname;
END;
$$ LANGUAGE plpgsql;

-- RostGIS Spatial Indexing Setup
-- This script sets up spatial indexing support for RostGIS
-- Run this after installing the RostGIS extension

\echo 'Setting up RostGIS Spatial Indexing...'

-- Create operator class for basic spatial indexing
-- This leverages the existing RostGIS spatial operators and support functions
CREATE OPERATOR CLASS gist_geometry_ops_simple
    FOR TYPE geometry USING gist AS
        -- Spatial operators (these are already implemented in RostGIS)
        OPERATOR        1       << (geometry, geometry),
        OPERATOR        2       &< (geometry, geometry), 
        OPERATOR        3       && (geometry, geometry),
        OPERATOR        4       &> (geometry, geometry),
        OPERATOR        5       >> (geometry, geometry),
        OPERATOR        6       ~= (geometry, geometry),
        OPERATOR        7       ~ (geometry, geometry),
        OPERATOR        8       @ (geometry, geometry),
        OPERATOR        9       &<| (geometry, geometry),
        OPERATOR        10      <<| (geometry, geometry),
        OPERATOR        11      |>> (geometry, geometry),
        OPERATOR        12      |&> (geometry, geometry),
        
        -- Support functions (using existing RostGIS functions)
        -- Note: We're using a minimal set that should work
        FUNCTION        2       geometry_gist_union(bbox[]),
        FUNCTION        3       geometry_gist_compress(geometry),
        FUNCTION        4       geometry_gist_decompress(bbox),
        FUNCTION        5       geometry_gist_penalty(bbox, bbox),
        FUNCTION        7       geometry_gist_same(bbox, bbox);

\echo 'Operator class created successfully!'

-- Create a demonstration table and test spatial indexing
DO $$
BEGIN
    -- Clean up any existing demo table
    DROP TABLE IF EXISTS rostgis_demo CASCADE;
    
    -- Create a demo table
    CREATE TABLE rostgis_demo (
        id SERIAL PRIMARY KEY,
        name TEXT,
        geom GEOMETRY
    );
    
    -- Insert some test data
    INSERT INTO rostgis_demo (name, geom) VALUES 
        ('Point A', ST_MakePoint(1, 1)),
        ('Point B', ST_MakePoint(2, 2)),
        ('Point C', ST_MakePoint(10, 10)),
        ('Point D', ST_MakePoint(1.5, 1.5)),
        ('Point E', ST_MakePoint(0, 0)),
        ('Point F', ST_MakePoint(-1, -1)),
        ('Point G', ST_MakePoint(5, 5));
    
    RAISE NOTICE 'Demo table created with % rows', (SELECT COUNT(*) FROM rostgis_demo);
    
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Error creating demo table: %', SQLERRM;
END $$;

-- Test spatial operations (these should work with or without indexes)
DO $$
DECLARE
    overlap_count INTEGER;
    distance_result NUMERIC;
BEGIN
    -- Test overlap operator
    SELECT COUNT(*) INTO overlap_count
    FROM rostgis_demo 
    WHERE geom && ST_MakePoint(1.5, 1.5);
    
    RAISE NOTICE 'Found % geometries overlapping with test point (1.5, 1.5)', overlap_count;
    
    -- Test distance function
    SELECT ST_Distance(ST_MakePoint(0, 0), ST_MakePoint(3, 4)) INTO distance_result;
    RAISE NOTICE 'Distance from (0,0) to (3,4): %', distance_result;
    
    -- Test other spatial relationships
    SELECT COUNT(*) INTO overlap_count
    FROM rostgis_demo 
    WHERE ST_DWithin(geom, ST_MakePoint(0, 0), 2.0);
    
    RAISE NOTICE 'Found % geometries within distance 2.0 of origin', overlap_count;
    
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Error in spatial operations test: %', SQLERRM;
END $$;

-- Try to create a spatial index (this may fail if GiST support is incomplete)
DO $$
BEGIN
    -- Try to create spatial index
    EXECUTE 'CREATE INDEX rostgis_demo_geom_idx ON rostgis_demo USING GIST (geom gist_geometry_ops_simple)';
    RAISE NOTICE 'âœ“ Successfully created spatial index on demo table!';
    RAISE NOTICE '  Index name: rostgis_demo_geom_idx';
    RAISE NOTICE '  Table: rostgis_demo';
    RAISE NOTICE '  Column: geom';
    
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'âœ— Could not create spatial index: %', SQLERRM;
    RAISE NOTICE '  This is expected if some GiST support functions are not fully implemented.';
    RAISE NOTICE '  Spatial operators will still work, just without index acceleration.';
    
    -- Try a simpler approach - create the table without specifying operator class
    BEGIN
        EXECUTE 'CREATE INDEX rostgis_demo_geom_simple_idx ON rostgis_demo USING GIST (geom)';
        RAISE NOTICE 'âœ“ Created basic spatial index without custom operator class';
    EXCEPTION WHEN OTHERS THEN
        RAISE NOTICE 'âœ— Basic spatial index also failed: %', SQLERRM;
    END;
END $$;

-- Show available spatial operators
\echo ''
\echo 'Available spatial operators:'

SELECT 
    op.oprname AS operator,
    op.oprleft::regtype AS left_type,
    op.oprright::regtype AS right_type,
    op.oprresult::regtype AS result_type,
    CASE 
        WHEN op.oprname = '&&' THEN 'bounding boxes overlap'
        WHEN op.oprname = '<<' THEN 'strictly left of'
        WHEN op.oprname = '>>' THEN 'strictly right of'
        WHEN op.oprname = '~' THEN 'contains'
        WHEN op.oprname = '@' THEN 'contained by'
        WHEN op.oprname = '~=' THEN 'same bounding box'
        WHEN op.oprname = '&<' THEN 'does not extend to right of'
        WHEN op.oprname = '&>' THEN 'does not extend to left of'
        WHEN op.oprname = '<<|' THEN 'strictly below'
        WHEN op.oprname = '|>>' THEN 'strictly above'
        WHEN op.oprname = '&<|' THEN 'does not extend above'
        WHEN op.oprname = '|&>' THEN 'does not extend below'
        ELSE 'spatial operator'
    END AS description
FROM pg_operator op
WHERE op.oprleft = 'geometry'::regtype 
   OR op.oprright = 'geometry'::regtype
ORDER BY op.oprname;

-- Show index information if any were created
\echo ''
\echo 'Indexes on demo table:'
SELECT 
    indexname,
    indexdef
FROM pg_indexes 
WHERE tablename = 'rostgis_demo'
ORDER BY indexname;

\echo ''
\echo 'ðŸŽ‰ RostGIS Spatial Indexing Setup Complete!'
\echo ''
\echo 'Quick Start Guide:'
\echo '=================='
\echo ''
\echo '1. Create a table with geometry column:'
\echo '   CREATE TABLE my_places (id SERIAL, name TEXT, geom GEOMETRY);'
\echo ''
\echo '2. Insert spatial data:'
\echo '   INSERT INTO my_places (name, geom) VALUES'
\echo '     (''Point A'', ST_MakePoint(1, 1)),'
\echo '     (''Point B'', ST_MakePoint(2, 2));'
\echo ''
\echo '3. Create spatial index:'
\echo '   CREATE INDEX my_places_geom_idx ON my_places USING GIST (geom gist_geometry_ops_simple);'
\echo '   -- OR if that fails:'
\echo '   CREATE INDEX my_places_geom_idx ON my_places USING GIST (geom);'
\echo ''
\echo '4. Run spatial queries:'
\echo '   SELECT name FROM my_places WHERE geom && ST_MakePoint(1.5, 1.5);'
\echo '   SELECT name FROM my_places WHERE ST_DWithin(geom, ST_MakePoint(0,0), 3.0);'
\echo ''
\echo '5. Check if index is being used:'
\echo '   EXPLAIN ANALYZE SELECT * FROM my_places WHERE geom && ST_MakePoint(1.5, 1.5);'
\echo ''
\echo 'For more information, see SPATIAL_INDEXING.md'
\echo '' 