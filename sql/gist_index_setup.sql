-- GiST Index Setup for RostGIS
-- This file creates the necessary operator class and index method for spatial indexing

-- First, create the GiST support functions if they don't exist
-- These are automatically generated by pgrx, but we need to reference them

-- Create the operator class for GiST indexing
-- This tells PostgreSQL how to use our geometry type with GiST indexes
CREATE OPERATOR CLASS gist_geometry_ops
    DEFAULT FOR TYPE geometry USING gist AS
        -- Storage type for index entries (bounding box)
        STORAGE bbox,
        
        -- Operators that can use the index (with strategy numbers)
        OPERATOR 1  << (geometry, geometry),          -- left
        OPERATOR 2  &< (geometry, geometry),          -- overleft  
        OPERATOR 3  && (geometry, geometry),          -- overlaps
        OPERATOR 4  &> (geometry, geometry),          -- overright
        OPERATOR 5  >> (geometry, geometry),          -- right
        OPERATOR 6  ~= (geometry, geometry),          -- same
        OPERATOR 7  ~ (geometry, geometry),           -- contains
        OPERATOR 8  @ (geometry, geometry),           -- contained
        OPERATOR 9  <<| (geometry, geometry),         -- below
        OPERATOR 10 &<| (geometry, geometry),         -- overbelow
        OPERATOR 11 |&> (geometry, geometry),         -- overabove
        OPERATOR 12 |>> (geometry, geometry),         -- above
        
        -- Support functions for the index implementation
        FUNCTION 1 geometry_gist_consistent(internal, bbox, smallint, oid, internal),
        FUNCTION 2 geometry_gist_union(internal, internal),
        FUNCTION 3 geometry_gist_compress(geometry),
        FUNCTION 4 geometry_gist_decompress(internal),
        FUNCTION 5 geometry_gist_penalty(internal, internal, internal),
        FUNCTION 6 geometry_gist_picksplit(internal, internal),
        FUNCTION 7 geometry_gist_same(bbox, bbox, internal);

-- Create some example spatial indexes to demonstrate usage
-- Note: These would typically be created by users on their tables

-- Example of creating a GiST index on a geometry column:
-- CREATE INDEX spatial_data_geom_idx ON spatial_data USING GIST (geom);

-- Create a helper function to create spatial indexes
CREATE OR REPLACE FUNCTION create_spatial_index(
    table_name TEXT,
    column_name TEXT DEFAULT 'geom',
    index_name TEXT DEFAULT NULL
) RETURNS TEXT AS $$
DECLARE
    idx_name TEXT;
BEGIN
    -- Generate index name if not provided
    IF index_name IS NULL THEN
        idx_name := table_name || '_' || column_name || '_idx';
    ELSE
        idx_name := index_name;
    END IF;
    
    -- Create the GiST index
    EXECUTE format('CREATE INDEX %I ON %I USING GIST (%I)', 
                   idx_name, table_name, column_name);
    
    -- Update table statistics
    EXECUTE format('ANALYZE %I', table_name);
    
    RETURN format('Created spatial index %s on %s.%s', idx_name, table_name, column_name);
END;
$$ LANGUAGE plpgsql;

-- Create a helper function to check if spatial indexes exist
CREATE OR REPLACE FUNCTION has_spatial_index(
    table_name TEXT,
    column_name TEXT DEFAULT 'geom'
) RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 
        FROM pg_class c
        JOIN pg_index i ON c.oid = i.indexrelid
        JOIN pg_class t ON i.indrelid = t.oid
        JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(i.indkey)
        JOIN pg_am am ON c.relam = am.oid
        WHERE t.relname = table_name
        AND a.attname = column_name
        AND am.amname = 'gist'
    );
END;
$$ LANGUAGE plpgsql;

-- Create a function to get index usage statistics
CREATE OR REPLACE FUNCTION spatial_index_stats(
    table_name TEXT DEFAULT NULL
) RETURNS TABLE (
    schema_name TEXT,
    table_name TEXT,
    index_name TEXT,
    column_name TEXT,
    index_size TEXT,
    idx_scan BIGINT,
    idx_tup_read BIGINT,
    idx_tup_fetch BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        n.nspname::TEXT,
        t.relname::TEXT,
        i.relname::TEXT,
        a.attname::TEXT,
        pg_size_pretty(pg_relation_size(i.oid))::TEXT,
        COALESCE(s.idx_scan, 0),
        COALESCE(s.idx_tup_read, 0), 
        COALESCE(s.idx_tup_fetch, 0)
    FROM pg_class i
    JOIN pg_index idx ON i.oid = idx.indexrelid
    JOIN pg_class t ON idx.indrelid = t.oid
    JOIN pg_namespace n ON t.relnamespace = n.oid
    JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(idx.indkey)
    JOIN pg_am am ON i.relam = am.oid
    LEFT JOIN pg_stat_user_indexes s ON s.indexrelid = i.oid
    WHERE am.amname = 'gist'
    AND (table_name IS NULL OR t.relname = spatial_index_stats.table_name)
    AND a.atttypid = (SELECT oid FROM pg_type WHERE typname = 'geometry')
    ORDER BY n.nspname, t.relname, i.relname;
END;
$$ LANGUAGE plpgsql;

-- Create a demonstration table and index for testing
DO $$
BEGIN
    -- Only create if not exists
    IF NOT EXISTS (SELECT FROM pg_tables WHERE tablename = 'rostgis_demo') THEN
        CREATE TABLE rostgis_demo (
            id SERIAL PRIMARY KEY,
            name TEXT,
            geom geometry,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        
        -- Insert some sample data
        INSERT INTO rostgis_demo (name, geom) VALUES
            ('Point A', ST_MakePoint(0, 0)),
            ('Point B', ST_MakePoint(1, 1)),
            ('Point C', ST_MakePoint(2, 2)),
            ('Point D', ST_MakePoint(10, 10)),
            ('Line AB', ST_GeomFromText('LINESTRING(0 0, 1 1)')),
            ('Square', ST_GeomFromText('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'));
        
        -- Create spatial index
        PERFORM create_spatial_index('rostgis_demo', 'geom');
        
        RAISE NOTICE 'Created rostgis_demo table with spatial index';
    END IF;
END
$$;

-- Provide usage examples in comments
/*
-- Example usage of spatial indexing:

-- 1. Create a table with spatial data
CREATE TABLE my_spatial_table (
    id SERIAL PRIMARY KEY,
    name TEXT,
    location geometry
);

-- 2. Create a spatial index (this will use GiST automatically)
SELECT create_spatial_index('my_spatial_table', 'location');

-- 3. Insert some data
INSERT INTO my_spatial_table (name, location) VALUES
    ('Location 1', ST_MakePoint(-122.4194, 37.7749)),  -- San Francisco
    ('Location 2', ST_MakePoint(-74.0060, 40.7128)),   -- New York
    ('Location 3', ST_MakePoint(-0.1276, 51.5074));    -- London

-- 4. Query using spatial operators (these will use the index)
-- Find all points that overlap with a bounding box:
SELECT * FROM my_spatial_table 
WHERE location && ST_MakePoint(-122.5, 37.7)::geometry;

-- Find points within a distance (simplified):
SELECT * FROM my_spatial_table 
WHERE ST_DWithin(location, ST_MakePoint(-122.4, 37.8), 0.1);

-- Check for spatial relationships:
SELECT * FROM my_spatial_table a, my_spatial_table b
WHERE a.id != b.id AND ST_Intersects(a.location, b.location);

-- 5. Check index usage
SELECT * FROM spatial_index_stats('my_spatial_table');

-- 6. Force index usage in query planning
SET enable_seqscan = false;
EXPLAIN (ANALYZE, BUFFERS) 
SELECT * FROM my_spatial_table 
WHERE location && ST_MakePoint(-122.5, 37.7)::geometry;
SET enable_seqscan = true;
*/ 